!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.15 (master) - 15 Apr 2020 11:54
!
!  Differentiation of besselj in reverse (adjoint) mode:
!   gradient     of useful results: res z
!   with respect to varying inputs: res z
!   RW status of diff variables: res:in-zero z:incr
SUBROUTINE BESSELJ_B(res, resb, v, z, zb, atol)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: v
  REAL*8, INTENT(IN) :: z, atol
  REAL*8 :: zb
  REAL*8 :: res
  REAL*8 :: resb
  REAL*8 :: s
  REAL*8 :: sb
  INTEGER :: k, i, factv
  INTRINSIC ABS
  REAL*8 :: abs0
  REAL*8 :: tempb
  INTEGER :: ad_count
  INTEGER :: i0
  INTEGER :: branch
  k = 0
  factv = 1
  DO i=2,v
    factv = factv*i
  END DO
  s = (z/2.0)**v/factv
  ad_count = 1
  DO WHILE (.true.)
    IF (s .GE. 0.) THEN
      abs0 = s
    ELSE
      abs0 = -s
    END IF
    IF (abs0 .GT. atol) THEN
      CALL PUSHINTEGER4(k)
      k = k + 1
      CALL PUSHREAL8(s)
      s = -(s/k/(k+v)*(z/2)**2)
      ad_count = ad_count + 1
    ELSE
      GOTO 100
    END IF
  END DO
  CALL PUSHCONTROL1B(0)
  GOTO 110
 100 CALL PUSHCONTROL1B(1)
 110 DO i0=1,ad_count
    IF (i0 .EQ. 1) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        sb = 0.0_8
      ELSE
        sb = 0.0_8
      END IF
    ELSE
      sb = sb + resb
      CALL POPREAL8(s)
      tempb = -(sb/(k*(k+v)*2**2))
      sb = z**2*tempb
      zb = zb + 2*z*s*tempb
      CALL POPINTEGER4(k)
    END IF
  END DO
  sb = sb + resb
  IF (.NOT.(z/2.0 .LE. 0.0 .AND. (v .EQ. 0.0 .OR. v .NE. INT(v)))) zb = &
&     zb + v*(z/2.0)**(v-1)*sb/(2.0*factv)
  resb = 0.0_8
END SUBROUTINE BESSELJ_B

subroutine besselj(res, v, z, atol)
    implicit none
	integer, intent(in) :: v
	real*8, intent(in) :: z, atol
	real*8, intent(out) :: res
	real*8 :: s
	integer :: k, i, factv
    k = 0
    factv = 1
    do i = 2,v
        factv = factv * i
    enddo

    s = (z/2.0)**v / factv
    res = s
    do while(abs(s) > atol)
        k = k + 1
        s = -s / k / (k+v) * ((z/2) ** 2)
        res = res + s
    enddo
endsubroutine besselj

program main
    real*8 :: res, resb, zb
    res = 0
    resb = 1
    zb = 0
    call besselj(res, 2, 1D0, 1D-8)
    call besselj_b(res, resb, 2, 1D0, zb, 1D-8)
    print*, res, resb, zb
endprogram main
